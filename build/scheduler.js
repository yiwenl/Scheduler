let n=window,e=60,o=performance.now(),r=0,t=0,a=o;const f=[],u=[],c=[],s=[];let i=[],l=[],g=0;!function g(){!function(){let n,g=0,m=1e3/e,p=0;for(g=0;g<f.length;g++)n=f[g],null!=n&&n.func(n.args);for(;i.length>0;)n=i.pop(),n.func(n.args);let h=performance.now();for(t=(h-o)/1e3,r=h-a,g=0;g<u.length;g++)n=u[g],h-n.time>n.delay&&(n.func(n.args),u.splice(g,1));for(h=performance.now();c.length>0;){if(n=c.shift(),p=performance.now(),console.log("Defer :",p,h,n.args.name,n.args.target),!(p-h<m)){console.log("not enough time, push to next frame",n.args.name),c.unshift(n);break}n.func(n.args)}for(h=performance.now();s.length>0;)n=s.shift(),p=performance.now(),p-h<m&&n.func(n.args);a=h,i=i.concat(l),l=[]}(),n.requestAnimationFrame(g)}();var m={addEF:function(n,e){const o=++g;return console.log("add task",o),f[o]={func:n,args:e},o},removeEF:function(n){return void 0!==f[n]&&(f[n]=null),-1},delay:function(n,e,o){const r=performance.now();u.push({func:n,args:e,delay:o,time:r})},next:function(n,e){l.push({func:n,args:e})},defer:function(n,e){c.push({func:n,args:e})},usurp:function(n,e){s.push({func:n,args:e})},setRequestAnimationFrameSource:function(e){n=e},setFrameRate:function(n){e=n},getElapsedTime:function(){return t},getDeltaTime:function(){return r}};export default m;
